# -*- coding: utf-8 -*-
"""Strategy Developement and Backtesting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sGEg3Kvts01WwfDZKY_OSvZVdmLDF3q1
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import backtrader as bt

trade_log = pd.DataFrame(columns=['Date', 'Strategy', 'Direction', 'Size', 'Entry Price', 'Exit Price', 'P&L'])

class TradeLoggingStrategy(bt.Strategy):
    def log_trade(self, trade_data):
        global trade_log
        trade_log = pd.concat([trade_log, pd.DataFrame([trade_data])], ignore_index=True)

class MovingAverageCrossoverStrategy(TradeLoggingStrategy):
    params = (('short_period', 50), ('long_period', 200),)

    def __init__(self):
        self.short_ma = bt.indicators.SMA(self.data.close, period=self.params.short_period)
        self.long_ma = bt.indicators.SMA(self.data.close, period=self.params.long_period)
        self.crossover = bt.indicators.CrossOver(self.short_ma, self.long_ma)

    def next(self):
        if self.crossover > 0:
            if not self.position:
                self.buy(size=0.1)
        elif self.crossover < 0:
            if self.position:
                self.sell(size=0.1)

    def notify_trade(self, trade):
        if trade.isclosed:
            direction = 'Buy' if trade.size > 0 else 'Sell'
            trade_data = {
                'Date': pd.Timestamp(self.data.datetime.date(0)),
                'Strategy': 'Moving Average Crossover',
                'Direction': direction,
                'Size': abs(trade.size),
                'Entry Price': trade.price,
                'Exit Price': trade.price + trade.pnl,
                'P&L': trade.pnl
            }
            self.log_trade(trade_data)

def backtest_strategy(strategy_class, data_feed):
    cerebro = bt.Cerebro()
    cerebro.addstrategy(strategy_class)
    cerebro.adddata(data_feed)
    cerebro.broker.setcash(100000)
    cerebro.broker.setcommission(commission=0.001)
    cerebro.run()
    return cerebro

file_path = 'banknifty.csv'
data = pd.read_csv(file_path, parse_dates=['date'], index_col='date')

data_feed = bt.feeds.PandasData(
    dataname=data,
    open='open',
    high='high',
    low='low',
    close='close',
    volume='volume'
)

cerebro = backtest_strategy(MovingAverageCrossoverStrategy, data_feed)

print(trade_log)
trade_log.to_csv('Trades.csv', index=False)

!pip install backtrader

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import backtrader as bt

trade_log = pd.DataFrame(columns=['Date', 'Strategy', 'Direction', 'Size', 'Entry Price', 'Exit Price', 'P&L'])

strategy_returns = []

class TradeLoggingStrategy(bt.Strategy):
    def log_trade(self, trade_data):
        global trade_log
        trade_log = pd.concat([trade_log, pd.DataFrame([trade_data])], ignore_index=True)

class MovingAverageCrossoverStrategy(TradeLoggingStrategy):
    params = (('short_period', 50), ('long_period', 200),)

    def __init__(self):
        self.short_ma = bt.indicators.SMA(self.data.close, period=self.params.short_period)
        self.long_ma = bt.indicators.SMA(self.data.close, period=self.params.long_period)
        self.crossover = bt.indicators.CrossOver(self.short_ma, self.long_ma)

    def next(self):
        global strategy_returns
        if self.crossover > 0:
            if not self.position:
                self.buy(size=0.1)
        elif self.crossover < 0:
            if self.position:
                self.sell(size=0.1)

        daily_return = (self.broker.getvalue() / self.broker.startingcash) - 1
        strategy_returns.append(daily_return)

    def notify_trade(self, trade):
        if trade.isclosed:
            direction = 'Buy' if trade.size > 0 else 'Sell'
            trade_data = {
                'Date': pd.Timestamp(self.data.datetime.date(0)),
                'Strategy': 'Moving Average Crossover',
                'Direction': direction,
                'Size': abs(trade.size),
                'Entry Price': trade.price,
                'Exit Price': trade.price + trade.pnl,
                'P&L': trade.pnl
            }
            self.log_trade(trade_data)

def backtest_strategy(strategy_class, data_feed):
    cerebro = bt.Cerebro()
    cerebro.addstrategy(strategy_class)
    cerebro.adddata(data_feed)
    cerebro.broker.setcash(100000)
    cerebro.broker.setcommission(commission=0.001)
    cerebro.run()
    return cerebro

file_path = 'banknifty.csv'
data = pd.read_csv(file_path, parse_dates=['date'], index_col='date')

data_feed = bt.feeds.PandasData(
    dataname=data,
    open='open',
    high='high',
    low='low',
    close='close',
    volume='volume'
)

cerebro = backtest_strategy(MovingAverageCrossoverStrategy, data_feed)


print(trade_log)
trade_log.to_csv('Trades.csv', index=False)

def calculate_performance_metrics(strategy_returns):
    strategy_returns = np.array(strategy_returns)
    daily_returns = strategy_returns[1:] - strategy_returns[:-1]
    annualized_return = np.mean(daily_returns) * 252
    cumulative_return = strategy_returns[-1]
    sharpe_ratio = np.mean(daily_returns) / np.std(daily_returns) * np.sqrt(252)
    sortino_ratio = np.mean(daily_returns) / np.std(daily_returns[daily_returns < 0]) * np.sqrt(252)
    max_drawdown = np.min(daily_returns.cumsum())
    return annualized_return, cumulative_return, sharpe_ratio, sortino_ratio, max_drawdown

annualized_return, cumulative_return, sharpe_ratio, sortino_ratio, max_drawdown = calculate_performance_metrics(strategy_returns)

performance_summary = {
    'Strategy': ['Moving Average Crossover'],
    'Annualized Return': [annualized_return],
    'Cumulative Return': [cumulative_return],
    'Sharpe Ratio': [sharpe_ratio],
    'Sortino Ratio': [sortino_ratio],
    'Max Drawdown': [max_drawdown]
}

performance_df = pd.DataFrame(performance_summary)
performance_df.to_csv('Strategy_Performance.csv', index=False)
print(performance_df)

strategy_returns_array = np.array(strategy_returns)

cumulative_returns = (1 + strategy_returns_array).cumprod() - 1

strategy_returns_df = pd.DataFrame({
    'Date': data.index[:len(cumulative_returns)],
    'Moving Average Crossover': cumulative_returns
}).set_index('Date')

plt.figure(figsize=(10, 6))
strategy_returns_df.plot(title='Equity Curves', linewidth=2)
plt.xlabel('Date')
plt.ylabel('Cumulative Returns')
plt.grid(True)
plt.savefig('equity_curves.png')
plt.show()

drawdowns = strategy_returns_df / strategy_returns_df.cummax() - 1

plt.figure(figsize=(10, 6))
drawdowns.plot(title='Drawdown Chart', linewidth=2)
plt.xlabel('Date')
plt.ylabel('Drawdown')
plt.grid(True)
plt.legend(title='Strategies')
plt.savefig('drawdown_chart.png')
plt.show()


returns = strategy_returns_df.pct_change().dropna()
correlation_matrix = returns.corr()

plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f', linewidths=.5)
plt.title('Correlation Matrix Between Strategies')
plt.savefig('correlation_matrix.png')
plt.show()

